import{_ as s,q as i,z as a,V as n}from"./chunks/framework.D-E96EZ1.js";const e=JSON.parse('{"title":"NestJS 使用 Redis 缓存：从接入到失效策略与最佳实践","description":"以 NestJS 为例介绍如何接入 Redis 做缓存，包括 CacheModule 接入、接口级缓存、手动缓存、缓存失效、Key 设计以及常见坑与最佳实践。","frontmatter":{"title":"NestJS 使用 Redis 缓存：从接入到失效策略与最佳实践","tags":["Node.js","NestJS","Redis","缓存","性能优化","学习笔记"],"categories":["后端"],"date":"2025-12-19T00:00:00.000Z","description":"以 NestJS 为例介绍如何接入 Redis 做缓存，包括 CacheModule 接入、接口级缓存、手动缓存、缓存失效、Key 设计以及常见坑与最佳实践。","articleGPT":"这篇文章从“为什么要缓存”讲起，给出 NestJS 中两种常见 Redis 缓存方案（cache-manager 与直接使用 Redis 客户端），并重点演示 CacheModule 的落地方式：全局配置、接口级缓存、手动 get/set、缓存失效（删除/更新）、Key 规范、以及缓存穿透/击穿/雪崩的应对策略。","references":[],"cover":"https://gitee.com/its-liu-xiaodi_admin/my_img/raw/image/redis.png","head":[["link",{"rel":"canonical","href":"https://liuxiaodi.icu/posts/2025/nestjs-redis-cache"}]]},"headers":[],"relativePath":"posts/2025/nestjs-redis-cache.md","filePath":"posts/2025/nestjs-redis-cache.md","lastUpdated":1766160067000}');const l=s({name:"posts/2025/nestjs-redis-cache.md"},[["render",function(s,e,l,p,t,h){return a(),i("div",null,[...e[0]||(e[0]=[n('<h2 id="为什么要在-nestjs-里用-redis-做缓存" tabindex="-1">为什么要在 NestJS 里用 Redis 做缓存？ <a class="header-anchor" href="#为什么要在-nestjs-里用-redis-做缓存" aria-label="Permalink to &quot;为什么要在 NestJS 里用 Redis 做缓存？&quot;">​</a></h2><p>缓存的核心目标很简单：<strong>用空间换时间</strong>。</p><p>典型收益：</p><ul><li><strong>降低数据库压力</strong>：热点接口不再每次都查 DB。</li><li><strong>降低接口延迟</strong>：命中缓存时直接从内存/Redis 返回。</li><li><strong>提升吞吐</strong>：同样的机器能支撑更多请求。</li></ul><p>典型适用场景：</p><ul><li>读多写少的列表/详情：文章详情、配置、字典表。</li><li>昂贵计算：聚合统计、复杂 SQL、跨服务拼装数据。</li><li>三方接口：调用成本高、限流严格，缓存结果避免重复请求。</li></ul><h2 id="两种做法-nest-缓存体系-vs-直接用-redis-客户端" tabindex="-1">两种做法：Nest 缓存体系 vs 直接用 Redis 客户端 <a class="header-anchor" href="#两种做法-nest-缓存体系-vs-直接用-redis-客户端" aria-label="Permalink to &quot;两种做法：Nest 缓存体系 vs 直接用 Redis 客户端&quot;">​</a></h2><p>在 NestJS 里使用 Redis 缓存，大体有两条路：</p><h3 id="方案-a-nestjs-cache-manager-redis-store-推荐先用这个" tabindex="-1">方案 A：<code>@nestjs/cache-manager</code> + Redis store（推荐先用这个） <a class="header-anchor" href="#方案-a-nestjs-cache-manager-redis-store-推荐先用这个" aria-label="Permalink to &quot;方案 A：`@nestjs/cache-manager` + Redis store（推荐先用这个）&quot;">​</a></h3><p>优点：</p><ul><li>和 Nest 的 <strong>依赖注入</strong>、<strong>拦截器</strong>天然契合。</li><li>接口级缓存可以直接用 <code>CacheInterceptor</code>。</li><li>可以统一管理默认 TTL、Key 前缀等。</li></ul><p>缺点：</p><ul><li>更复杂的策略（tag 失效、分布式锁、预热等）需要自己扩展。</li><li>不同 Nest / cache-manager / store 版本间有兼容性差异，升级要留意。</li></ul><h3 id="方案-b-直接用-redis-ioredis-更灵活" tabindex="-1">方案 B：直接用 <code>redis</code> / <code>ioredis</code>（更灵活） <a class="header-anchor" href="#方案-b-直接用-redis-ioredis-更灵活" aria-label="Permalink to &quot;方案 B：直接用 `redis` / `ioredis`（更灵活）&quot;">​</a></h3><p>优点：</p><ul><li>可控性最强：pipeline、lua、分布式锁、复杂 Key 结构都能做。</li><li>适合复杂业务缓存（多 Key 同时失效、缓存预热、延迟双删等）。</li></ul><p>缺点：</p><ul><li>需要自己封装一层缓存工具与规范。</li></ul><p>本文以 <strong>方案 A 为主</strong>，最后补一个 <strong>方案 B 的封装思路</strong>。</p><hr><h2 id="准备-启动-redis" tabindex="-1">准备：启动 Redis <a class="header-anchor" href="#准备-启动-redis" aria-label="Permalink to &quot;准备：启动 Redis&quot;">​</a></h2><p>本地开发可以用 Docker：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> redis</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 6379:6379</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> redis:7</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>生产建议：</p><ul><li>设定最大内存与淘汰策略（例如 <code>allkeys-lru</code>）。</li><li>开启密码与网络隔离（不要裸奔在公网）。</li><li>监控：QPS、内存、命中率、慢查询、key 数量。</li></ul><hr><h2 id="方案-a-用-cachemodule-接入-redis-全局配置" tabindex="-1">方案 A：用 CacheModule 接入 Redis（全局配置） <a class="header-anchor" href="#方案-a-用-cachemodule-接入-redis-全局配置" aria-label="Permalink to &quot;方案 A：用 CacheModule 接入 Redis（全局配置）&quot;">​</a></h2><h3 id="_1-安装依赖" tabindex="-1">1）安装依赖 <a class="header-anchor" href="#_1-安装依赖" aria-label="Permalink to &quot;1）安装依赖&quot;">​</a></h3><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> @nestjs/cache-manager</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cache-manager</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cache-manager-redis-store</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>如果你项目是 ESM 或 Nest 版本更新较快，建议固定依赖版本并在 CI 里跑一次启动验证，避免 store 兼容性问题。</p></blockquote><h3 id="_2-在-appmodule-注册缓存-建议全局" tabindex="-1">2）在 <code>AppModule</code> 注册缓存（建议全局） <a class="header-anchor" href="#_2-在-appmodule-注册缓存-建议全局" aria-label="Permalink to &quot;2）在 `AppModule` 注册缓存（建议全局）&quot;">​</a></h3><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Module } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@nestjs/common&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { CacheModule } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@nestjs/cache-manager&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { redisStore } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;cache-manager-redis-store&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  imports: [</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    CacheModule.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">registerAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      isGlobal: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      useFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        store: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> redisStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          socket: {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            host: process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">REDIS_HOST</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ??</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;127.0.0.1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            port: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">REDIS_PORT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ??</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          },</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // password: process.env.REDIS_PASSWORD,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }),</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ttl: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">60</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }),</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }),</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ],</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AppModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><ul><li><code>ttl</code>：默认缓存时间（秒）。实际建议按接口设置，不要“一刀切”。</li><li><code>isGlobal: true</code>：全局可用，不用每个模块重复 imports。</li></ul><hr><h2 id="接口级缓存-cacheinterceptor" tabindex="-1">接口级缓存：<code>CacheInterceptor</code> <a class="header-anchor" href="#接口级缓存-cacheinterceptor" aria-label="Permalink to &quot;接口级缓存：`CacheInterceptor`&quot;">​</a></h2><h3 id="_1-快速给-get-接口加缓存" tabindex="-1">1）快速给 GET 接口加缓存 <a class="header-anchor" href="#_1-快速给-get-接口加缓存" aria-label="Permalink to &quot;1）快速给 GET 接口加缓存&quot;">​</a></h3><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Controller, Get, UseInterceptors } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@nestjs/common&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { CacheInterceptor, CacheTTL } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@nestjs/cache-manager&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Controller</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;posts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UseInterceptors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CacheInterceptor)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PostsController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hot&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CacheTTL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  async</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hotPosts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 这里假设是昂贵查询</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [{ id: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, title: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hot post&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }];</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>说明：</p><ul><li><code>CacheInterceptor</code> 会对返回值进行缓存。</li><li><code>@CacheTTL(30)</code> 覆盖默认 TTL。</li></ul><h3 id="_2-key-如何生成-重要" tabindex="-1">2）Key 如何生成？（重要） <a class="header-anchor" href="#_2-key-如何生成-重要" aria-label="Permalink to &quot;2）Key 如何生成？（重要）&quot;">​</a></h3><p>默认情况下拦截器会基于请求信息生成 key（通常包含 URL）。</p><p>但在真实项目里你通常需要：</p><ul><li>给 key 加业务前缀（避免跨系统冲突）</li><li>把 query 参数、用户身份、分页信息纳入 key</li></ul><p>可以用 <code>@CacheKey()</code> 人工指定 key（适合简单且 key 固定的接口）：</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { CacheInterceptor, CacheKey, CacheTTL } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@nestjs/cache-manager&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CacheKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;posts:hot&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CacheTTL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hot&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hotPosts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.postsService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getHotPosts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>如果 key 需要动态拼（比如分页/筛选），建议走“手动缓存”的方式（下一节）。</p></blockquote><hr><h2 id="手动缓存-在-service-中-get-set-更通用" tabindex="-1">手动缓存：在 Service 中 get/set（更通用） <a class="header-anchor" href="#手动缓存-在-service-中-get-set-更通用" aria-label="Permalink to &quot;手动缓存：在 Service 中 get/set（更通用）&quot;">​</a></h2><p>很多时候你需要更细粒度控制：</p><ul><li>Key 包含分页、筛选、用户</li><li>命中缓存直接返回，未命中才查询 DB</li><li>写操作后主动删除相关缓存</li></ul><h3 id="_1-注入-cache-manager" tabindex="-1">1）注入 <code>CACHE_MANAGER</code> <a class="header-anchor" href="#_1-注入-cache-manager" aria-label="Permalink to &quot;1）注入 `CACHE_MANAGER`&quot;">​</a></h3><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Injectable, Inject } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@nestjs/common&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { CACHE_MANAGER } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@nestjs/cache-manager&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Cache } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;cache-manager&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Injectable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PostsService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CACHE_MANAGER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Cache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {}</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_2-实现-缓存优先-的读取" tabindex="-1">2）实现“缓存优先”的读取 <a class="header-anchor" href="#_2-实现-缓存优先-的读取" aria-label="Permalink to &quot;2）实现“缓存优先”的读取&quot;">​</a></h3><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">async </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getPostDetail</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postId: number) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `posts:detail:${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">postId</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cached</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(key);</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (cached) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cached;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">queryFromDb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postId);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  await</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, data, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">120</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>建议：</p><ul><li><code>key</code> 明确包含领域前缀与业务含义。</li><li><code>ttl</code> 不要太长，避免数据长期不一致。</li><li>序列化：cache-manager 默认会把对象存起来（底层 store 可能会 JSON 化），但你依旧要确保返回值是可序列化的纯数据。</li></ul><hr><h2 id="缓存失效-删除-更新-怎么做" tabindex="-1">缓存失效（删除 / 更新）怎么做？ <a class="header-anchor" href="#缓存失效-删除-更新-怎么做" aria-label="Permalink to &quot;缓存失效（删除 / 更新）怎么做？&quot;">​</a></h2><p>缓存最大的问题不是“写不进去”，而是“数据变了怎么办”。</p><h3 id="_1-写操作后删除缓存-常用" tabindex="-1">1）写操作后删除缓存（常用） <a class="header-anchor" href="#_1-写操作后删除缓存-常用" aria-label="Permalink to &quot;1）写操作后删除缓存（常用）&quot;">​</a></h3><p>比如更新文章：</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">async </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">updatePost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postId: number, payload: any) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> updated</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">updateDb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(postId, payload);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  await</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">del</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`posts:detail:${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">postId</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  await</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">del</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;posts:list:hot&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> updated;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这叫 <strong>Cache Aside（旁路缓存）模式</strong>：</p><ul><li>读：先读缓存，没命中读 DB，再写缓存</li><li>写：先写 DB，再删缓存（让下一次读回源 DB 再重建缓存）</li></ul><h3 id="_2-延迟双删-写多读多、并发较高时考虑" tabindex="-1">2）延迟双删（写多读多、并发较高时考虑） <a class="header-anchor" href="#_2-延迟双删-写多读多、并发较高时考虑" aria-label="Permalink to &quot;2）延迟双删（写多读多、并发较高时考虑）&quot;">​</a></h3><p>在极端并发下可能出现：</p><ul><li>A 更新 DB -&gt; 删缓存</li><li>B 读到缓存未命中 -&gt; 回源 DB（但 DB 还没提交/或读到旧数据）-&gt; 写回旧缓存</li></ul><p>一种工程化做法是 <strong>延迟双删</strong>：</p><ul><li>写 DB</li><li>删除缓存</li><li>等待一个短延迟（比如 200~500ms，视数据库事务时间）</li><li>再删除一次缓存</li></ul><p>是否需要用到它取决于业务一致性要求与并发情况。</p><hr><h2 id="key-设计规范-强烈建议统一" tabindex="-1">Key 设计规范（强烈建议统一） <a class="header-anchor" href="#key-设计规范-强烈建议统一" aria-label="Permalink to &quot;Key 设计规范（强烈建议统一）&quot;">​</a></h2><p>推荐 key 结构：</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{app}:{domain}:{resource}:{identifier}:{version?}:{params_hash?}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>例如：</p><ul><li><code>blog:posts:detail:123</code></li><li><code>blog:posts:list:hot:v1</code></li><li><code>blog:posts:list:search:v1:kw=nestjs&amp;page=1&amp;pageSize=20</code>（更建议把 params 做 hash，避免 key 过长）</li></ul><p>要点：</p><ul><li><strong>前缀隔离</strong>：防止不同项目/不同环境 key 冲突。</li><li><strong>可读</strong>：排障时能一眼看懂是什么。</li><li><strong>可控长度</strong>：key 太长会影响内存与网络。</li><li><strong>版本号</strong>：当你改了缓存结构，可以直接升级 <code>v1 -&gt; v2</code>，避免旧缓存污染。</li></ul><hr><h2 id="常见缓存问题与应对" tabindex="-1">常见缓存问题与应对 <a class="header-anchor" href="#常见缓存问题与应对" aria-label="Permalink to &quot;常见缓存问题与应对&quot;">​</a></h2><h3 id="_1-缓存穿透-大量请求不存在的数据" tabindex="-1">1）缓存穿透（大量请求不存在的数据） <a class="header-anchor" href="#_1-缓存穿透-大量请求不存在的数据" aria-label="Permalink to &quot;1）缓存穿透（大量请求不存在的数据）&quot;">​</a></h3><p>现象：请求的 id 根本不存在，导致每次都回源 DB。</p><p>应对：</p><ul><li>缓存“空值”（短 TTL，例如 10~30 秒）</li><li>或使用布隆过滤器（复杂一点，但很有效）</li></ul><h3 id="_2-缓存击穿-热点-key-过期瞬间大量回源" tabindex="-1">2）缓存击穿（热点 key 过期瞬间大量回源） <a class="header-anchor" href="#_2-缓存击穿-热点-key-过期瞬间大量回源" aria-label="Permalink to &quot;2）缓存击穿（热点 key 过期瞬间大量回源）&quot;">​</a></h3><p>现象：某个超热点 key 刚好过期，大量请求同时回源 DB。</p><p>应对：</p><ul><li>给热点 key 做“互斥锁重建”（单飞）</li><li>或做“提前刷新/后台预热”</li><li>TTL 加随机抖动（避免同一批 key 同时过期）</li></ul><h3 id="_3-缓存雪崩-大量-key-同时过期" tabindex="-1">3）缓存雪崩（大量 key 同时过期） <a class="header-anchor" href="#_3-缓存雪崩-大量-key-同时过期" aria-label="Permalink to &quot;3）缓存雪崩（大量 key 同时过期）&quot;">​</a></h3><p>现象：一大片 key 同时失效，引发 DB 被打爆。</p><p>应对：</p><ul><li>TTL 加随机抖动（例如 <code>ttl = base + random(0..30)</code>）</li><li>分批预热</li><li>限流/熔断/降级</li></ul><hr><h2 id="方案-b-直接用-redis-客户端的封装思路-简版" tabindex="-1">方案 B：直接用 Redis 客户端的封装思路（简版） <a class="header-anchor" href="#方案-b-直接用-redis-客户端的封装思路-简版" aria-label="Permalink to &quot;方案 B：直接用 Redis 客户端的封装思路（简版）&quot;">​</a></h2><p>如果你打算做更复杂策略（分布式锁、pipeline、lua、tag 失效），建议直接用 <code>ioredis</code> 或官方 <code>redis</code> 客户端，然后在 Nest 里封装一个 <code>RedisService</code>。</p><p>你一般会封装这些能力：</p><ul><li><code>getJson(key)</code> / <code>setJson(key, value, ttl)</code></li><li><code>del(keys)</code> 支持批量删除</li><li><code>withLock(lockKey, ttl, fn)</code> 支持互斥重建</li><li>key 规范：统一在一个地方生成，避免到处拼字符串</li></ul><p>如果你希望我把这套封装按你仓库的 Nest 项目结构（module/service）写成可直接复制的代码，我可以再补一篇“代码落地版”。</p><hr><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>本文用 NestJS 介绍了 Redis 缓存的常见落地方式：</p><ul><li><strong>CacheModule 接入 Redis</strong>：统一管理缓存能力</li><li><strong>接口级缓存</strong>：<code>CacheInterceptor</code> + <code>@CacheTTL</code> 快速提升性能</li><li><strong>手动缓存</strong>：在 Service 中 <code>get/set/del</code>，实现可控 key 与失效策略</li><li><strong>最佳实践</strong>：Key 设计、TTL 策略，以及穿透/击穿/雪崩的应对</li></ul><p>下一步你可以在自己的业务里选一个“慢接口/热点接口”，优先把它改造成 cache-aside，并配上合理的失效策略与监控（命中率、回源率），通常会很快看到收益。</p>',103)])])}]]);export{e as __pageData,l as default};
