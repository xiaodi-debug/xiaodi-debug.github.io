import{_ as s,q as i,z as a,V as n}from"./chunks/framework.D-E96EZ1.js";const l=JSON.parse('{"title":"NestJS + TypeORM：连接池配置与多租户实践（可落地方案）","description":"介绍在 NestJS 中使用 TypeORM 时如何正确配置连接池，并给出多租户（单库多租户 / 多库多租户）两种常见实现方案：租户解析、DataSource 管理、Provider 注入、迁移策略与常见坑。","frontmatter":{"title":"NestJS + TypeORM：连接池配置与多租户实践（可落地方案）","tags":["Node.js","NestJS","TypeORM","MySQL","PostgreSQL","连接池","多租户","架构"],"categories":["后端"],"comment":true,"date":"2025-12-19T00:00:00.000Z","description":"介绍在 NestJS 中使用 TypeORM 时如何正确配置连接池，并给出多租户（单库多租户 / 多库多租户）两种常见实现方案：租户解析、DataSource 管理、Provider 注入、迁移策略与常见坑。","articleGPT":"这篇文章从 TypeORM 的连接池参数与并发模型讲起，先说明“多连接 vs 连接池”的区别，然后重点讲多租户的两条主线：共享数据库（tenant_id 隔离）与按租户独立数据库（DataSource per tenant）。文章给出 NestJS 中解析租户（中间件/守卫/请求上下文）、按租户复用 DataSource、连接池与回收、迁移与索引、以及穿透与安全边界等最佳实践。","references":[],"cover":"https://gitee.com/its-liu-xiaodi_admin/my_img/raw/image/typeorm.png","head":[["link",{"rel":"canonical","href":"https://liuxiaodi.icu/posts/2025/nestjs-typeorm-multitenancy-pool"}]]},"headers":[],"relativePath":"posts/2025/nestjs-typeorm-multitenancy-pool.md","filePath":"posts/2025/nestjs-typeorm-multitenancy-pool.md","lastUpdated":1766415456000}');const e=s({name:"posts/2025/nestjs-typeorm-multitenancy-pool.md"},[["render",function(s,l,e,t,p,h){return a(),i("div",null,[...l[0]||(l[0]=[n("",126)])])}]]);export{l as __pageData,e as default};
