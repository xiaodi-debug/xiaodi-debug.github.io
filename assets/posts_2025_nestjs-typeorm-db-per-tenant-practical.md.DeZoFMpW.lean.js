import{_ as s,q as i,z as a,V as n}from"./chunks/framework.D-E96EZ1.js";const l=JSON.parse('{"title":"NestJS + TypeORM 多库多租户（DB per tenant）代码落地：DataSource 管理、并发单飞与回收","description":"多库多租户（每个租户一个数据库）在 NestJS + TypeORM v0.3+ 下的可落地实现：tenant 解析、TenantDataSourceManager（并发单飞锁）、REQUEST scope provider 注入、Repository/EntityManager 使用方式、连接池容量规划与回收策略。","frontmatter":{"title":"NestJS + TypeORM 多库多租户（DB per tenant）代码落地：DataSource 管理、并发单飞与回收","tags":["Node.js","NestJS","TypeORM","MySQL","PostgreSQL","多租户","连接池","架构","实战"],"categories":["后端"],"date":"2025-12-19T00:00:00.000Z","description":"多库多租户（每个租户一个数据库）在 NestJS + TypeORM v0.3+ 下的可落地实现：tenant 解析、TenantDataSourceManager（并发单飞锁）、REQUEST scope provider 注入、Repository/EntityManager 使用方式、连接池容量规划与回收策略。","articleGPT":"这篇文章给出一个可直接照抄的 NestJS 多库多租户实现骨架：通过中间件解析 tenantId，使用 TenantRegistry 存储租户数据库连接信息，用 TenantDataSourceManager 缓存/复用 DataSource 并用 in-flight promise 防止并发重复初始化；再用 REQUEST scope provider 将当前租户的 DataSource 或 EntityManager 注入业务层。最后补充连接数容量公式、LRU/TTL 回收、迁移策略与常见坑。","references":[],"cover":"https://gitee.com/its-liu-xiaodi_admin/my_img/raw/image/nestjs.png","head":[["link",{"rel":"canonical","href":"https://liuxiaodi.icu/posts/2025/nestjs-typeorm-db-per-tenant-practical"}]]},"headers":[],"relativePath":"posts/2025/nestjs-typeorm-db-per-tenant-practical.md","filePath":"posts/2025/nestjs-typeorm-db-per-tenant-practical.md","lastUpdated":1766160067000}');const p=s({name:"posts/2025/nestjs-typeorm-db-per-tenant-practical.md"},[["render",function(s,l,p,t,e,h){return a(),i("div",null,[...l[0]||(l[0]=[n("",96)])])}]]);export{l as __pageData,p as default};
