import{_ as s,q as i,z as a,V as n}from"./chunks/framework.D-E96EZ1.js";const l=JSON.parse('{"title":"NestJS + TypeORM：连接池配置与多租户实践（可落地方案）","description":"介绍在 NestJS 中使用 TypeORM 时如何正确配置连接池，并给出多租户（单库多租户 / 多库多租户）两种常见实现方案：租户解析、DataSource 管理、Provider 注入、迁移策略与常见坑。","frontmatter":{"title":"NestJS + TypeORM：连接池配置与多租户实践（可落地方案）","tags":["Node.js","NestJS","TypeORM","MySQL","PostgreSQL","连接池","多租户","架构"],"categories":["后端"],"date":"2025-12-19T00:00:00.000Z","description":"介绍在 NestJS 中使用 TypeORM 时如何正确配置连接池，并给出多租户（单库多租户 / 多库多租户）两种常见实现方案：租户解析、DataSource 管理、Provider 注入、迁移策略与常见坑。","articleGPT":"这篇文章从 TypeORM 的连接池参数与并发模型讲起，先说明“多连接 vs 连接池”的区别，然后重点讲多租户的两条主线：共享数据库（tenant_id 隔离）与按租户独立数据库（DataSource per tenant）。文章给出 NestJS 中解析租户（中间件/守卫/请求上下文）、按租户复用 DataSource、连接池与回收、迁移与索引、以及穿透与安全边界等最佳实践。","references":[],"cover":"https://gitee.com/its-liu-xiaodi_admin/my_img/raw/image/typeorm.png","head":[["link",{"rel":"canonical","href":"https://liuxiaodi.icu/posts/2025/nestjs-typeorm-multitenancy-pool"}]]},"headers":[],"relativePath":"posts/2025/nestjs-typeorm-multitenancy-pool.md","filePath":"posts/2025/nestjs-typeorm-multitenancy-pool.md","lastUpdated":1766160067000}');const e=s({name:"posts/2025/nestjs-typeorm-multitenancy-pool.md"},[["render",function(s,l,e,t,p,h){return a(),i("div",null,[...l[0]||(l[0]=[n('<h2 id="先说清楚-你要的-多线程池-是什么" tabindex="-1">先说清楚：你要的“多线程池”是什么？ <a class="header-anchor" href="#先说清楚-你要的-多线程池-是什么" aria-label="Permalink to &quot;先说清楚：你要的“多线程池”是什么？&quot;">​</a></h2><p>很多同学说的“多线程池”，在 Node.js 服务里通常指的是：</p><ul><li><strong>数据库连接池（connection pool）</strong>：同一时间复用多条 DB 连接，提升并发。</li><li><strong>多 DataSource / 多连接池</strong>：比如读写分离、分库分表、或多租户（每个租户一个库）。</li></ul><p>TypeORM 在 Node.js 中跑在单线程事件循环上，但数据库 I/O 是异步的；真正决定并发能力的，往往是：</p><ul><li>DB 端能扛多少连接</li><li>连接池 <code>max</code>（或类似参数）配置是否合理</li><li>查询是否有索引、是否有 N+1、是否有慢 SQL</li></ul><p>所以本文会把重点放在：</p><ul><li><strong>如何在 NestJS + TypeORM 正确配置连接池</strong></li><li><strong>如何实现多租户</strong>（并保证隔离与可维护性）</li></ul><hr><h2 id="part-1-typeorm-连接池怎么配" tabindex="-1">Part 1：TypeORM 连接池怎么配？ <a class="header-anchor" href="#part-1-typeorm-连接池怎么配" aria-label="Permalink to &quot;Part 1：TypeORM 连接池怎么配？&quot;">​</a></h2><h3 id="_1-typeorm-的池来自哪里" tabindex="-1">1）TypeORM 的池来自哪里？ <a class="header-anchor" href="#_1-typeorm-的池来自哪里" aria-label="Permalink to &quot;1）TypeORM 的池来自哪里？&quot;">​</a></h3><p>TypeORM 本身不实现连接池，它依赖驱动：</p><ul><li>MySQL/MariaDB：通常由 <code>mysql2</code> 提供 pool</li><li>PostgreSQL：由 <code>pg</code> 提供 pool</li></ul><p>在 TypeORM v0.3+ 里你一般通过 <code>DataSourceOptions.extra</code>（或对应驱动参数）把 pool 配置透传进去。</p><h3 id="_2-示例-mysql-mysql2-连接池参数" tabindex="-1">2）示例：MySQL（mysql2）连接池参数 <a class="header-anchor" href="#_2-示例-mysql-mysql2-连接池参数" aria-label="Permalink to &quot;2）示例：MySQL（mysql2）连接池参数&quot;">​</a></h3><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { TypeOrmModule } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@nestjs/typeorm&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TypeOrmModule.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forRoot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mysql&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  host: process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DB_HOST</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  port: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DB_PORT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ??</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3306</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  username: process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DB_USER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  password: process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DB_PASS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  database: process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DB_NAME</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  autoLoadEntities: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  synchronize: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 关键：透传给 mysql2 的 pool 配置</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  extra: {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    connectionLimit: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 池内最大连接数（核心参数）</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // queueLimit: 0,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 请求排队上限（0=无限）</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // waitForConnections: true,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>建议：</p><ul><li><code>connectionLimit</code> 不要乱拉高：DB 连接不是越多越好。</li><li>先用压测/监控观察：QPS、平均耗时、99 线、DB CPU、慢查询。</li></ul><h3 id="_3-示例-postgresql-pg-连接池参数" tabindex="-1">3）示例：PostgreSQL（pg）连接池参数 <a class="header-anchor" href="#_3-示例-postgresql-pg-连接池参数" aria-label="Permalink to &quot;3）示例：PostgreSQL（pg）连接池参数&quot;">​</a></h3><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TypeOrmModule.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forRoot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;postgres&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  host: process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DB_HOST</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  port: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DB_PORT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ??</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5432</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  username: process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DB_USER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  password: process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DB_PASS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  database: process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DB_NAME</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  autoLoadEntities: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  synchronize: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  extra: {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// pg pool 最大连接数</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    idleTimeoutMillis: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    connectionTimeoutMillis: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="_4-连接池应该配多大" tabindex="-1">4）连接池应该配多大？ <a class="header-anchor" href="#_4-连接池应该配多大" aria-label="Permalink to &quot;4）连接池应该配多大？&quot;">​</a></h3><p>一个简单的经验：</p><ul><li><strong>从小开始</strong>（例如 10~30），观察瓶颈再调</li><li>结合 DB 的 <code>max_connections</code> / 实例规格</li><li>对于高并发读：优先优化索引和 SQL，其次才是加大连接池</li></ul><p>过大的连接池常见副作用：</p><ul><li>DB CPU 飙升，锁竞争更严重</li><li>平均响应时间反而变差（抖动更大）</li><li>在多实例部署时，连接数会按实例倍增（容易打满 DB）</li></ul><hr><h2 id="part-2-多租户怎么做-两条路线先选清楚" tabindex="-1">Part 2：多租户怎么做？两条路线先选清楚 <a class="header-anchor" href="#part-2-多租户怎么做-两条路线先选清楚" aria-label="Permalink to &quot;Part 2：多租户怎么做？两条路线先选清楚&quot;">​</a></h2><p>多租户（Multi-tenancy）的本质是：<strong>同一套服务，服务多个“租户”</strong>，并确保数据隔离。</p><p>最常见两种模式：</p><h3 id="模式-a-单库多租户-shared-database-shared-schema" tabindex="-1">模式 A：单库多租户（Shared Database, Shared Schema） <a class="header-anchor" href="#模式-a-单库多租户-shared-database-shared-schema" aria-label="Permalink to &quot;模式 A：单库多租户（Shared Database, Shared Schema）&quot;">​</a></h3><ul><li>所有租户共享一个数据库/表结构</li><li>每张业务表都有 <code>tenant_id</code></li></ul><p>优点：</p><ul><li>成本低、运维简单</li><li>新租户接入快（无需建库/迁移）</li></ul><p>缺点：</p><ul><li>隔离弱：需要非常严格的代码约束，避免越权</li><li>单库膨胀快，热点租户会影响其他租户</li></ul><p>适合：租户数量多、小租户为主、隔离要求中等。</p><h3 id="模式-b-多库多租户-database-per-tenant" tabindex="-1">模式 B：多库多租户（Database per Tenant） <a class="header-anchor" href="#模式-b-多库多租户-database-per-tenant" aria-label="Permalink to &quot;模式 B：多库多租户（Database per Tenant）&quot;">​</a></h3><ul><li>每个租户一个独立数据库（或一个独立 schema）</li><li>服务按请求中的租户信息选择对应 DB 连接</li></ul><p>优点：</p><ul><li>隔离强（天然隔离）</li><li>大租户可独立扩容与迁移</li></ul><p>缺点：</p><ul><li>运维成本高：建库、迁移、备份、监控都要按租户维度做</li><li>连接数更容易爆：多个 DataSource + 每个都有 pool</li></ul><p>适合：租户数量不多、付费大客户、强隔离要求。</p><blockquote><p>下面我会分别给出两套实现思路。你可以先选一个模式落地。</p></blockquote><hr><h2 id="part-3-单库多租户-tenant-id-隔离-落地方案" tabindex="-1">Part 3：单库多租户（tenant_id 隔离）落地方案 <a class="header-anchor" href="#part-3-单库多租户-tenant-id-隔离-落地方案" aria-label="Permalink to &quot;Part 3：单库多租户（tenant_id 隔离）落地方案&quot;">​</a></h2><h3 id="_1-关键点" tabindex="-1">1）关键点 <a class="header-anchor" href="#_1-关键点" aria-label="Permalink to &quot;1）关键点&quot;">​</a></h3><ul><li><strong>租户识别</strong>：从 <code>Header</code>/子域名/JWT 中解析 <code>tenantId</code></li><li><strong>把 tenantId 注入请求上下文</strong>：后续 service 能拿到</li><li><strong>所有查询强制带 tenantId 条件</strong>：这是安全边界</li></ul><h3 id="_2-租户从哪里来-推荐顺序" tabindex="-1">2）租户从哪里来？（推荐顺序） <a class="header-anchor" href="#_2-租户从哪里来-推荐顺序" aria-label="Permalink to &quot;2）租户从哪里来？（推荐顺序）&quot;">​</a></h3><ul><li>从 JWT <code>payload</code>（登录时确定 tenant，后续可信）</li><li>从 Header（例如 <code>x-tenant-id</code>，适合内部系统，但要防伪造）</li><li>从子域名（例如 <code>tenantA.api.xxx.com</code>）</li></ul><h3 id="_3-在-nest-中保存-tenantid-请求级上下文" tabindex="-1">3）在 Nest 中保存 tenantId（请求级上下文） <a class="header-anchor" href="#_3-在-nest-中保存-tenantid-请求级上下文" aria-label="Permalink to &quot;3）在 Nest 中保存 tenantId（请求级上下文）&quot;">​</a></h3><p>你可以用中间件把 <code>tenantId</code> 挂到 <code>req</code> 上：</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Injectable, NestMiddleware, BadRequestException } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@nestjs/common&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Request, Response, NextFunction } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;express&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Injectable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TenantMiddleware</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NestMiddleware</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">req</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Request</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">tenantId</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">_res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Response</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NextFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tenantId</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> req.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;x-tenant-id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tenantId) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BadRequestException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Missing x-tenant-id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    req.tenantId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tenantId;</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="_4-查询时强制带-tenantid" tabindex="-1">4）查询时强制带 tenantId <a class="header-anchor" href="#_4-查询时强制带-tenantid" aria-label="Permalink to &quot;4）查询时强制带 tenantId&quot;">​</a></h3><p>最朴素的做法：在 service 里每个 repository 查询都带上 <code>tenantId</code>。</p><p>更推荐：</p><ul><li>封装一个 <code>TenantRepository</code></li><li>或者在 QueryBuilder 的基础上统一追加 <code>tenant_id</code></li></ul><p>并且要做到：</p><ul><li><strong>写入时自动填 tenant_id</strong></li><li><strong>更新/删除必须带 tenant_id 条件</strong>（否则就是越权漏洞）</li></ul><h3 id="_5-表结构与索引" tabindex="-1">5）表结构与索引 <a class="header-anchor" href="#_5-表结构与索引" aria-label="Permalink to &quot;5）表结构与索引&quot;">​</a></h3><p>单库多租户一定要注意索引：</p><ul><li>绝大多数查询都需要 <code>tenant_id</code> 参与过滤</li><li>常见组合索引：<code>(tenant_id, id)</code>、<code>(tenant_id, created_at)</code>、<code>(tenant_id, status, created_at)</code></li></ul><p>否则你会看到：</p><ul><li>明明加了缓存/连接池，接口还是慢（根本原因是慢 SQL）</li></ul><hr><h2 id="part-4-多库多租户-datasource-per-tenant-落地方案" tabindex="-1">Part 4：多库多租户（DataSource per tenant）落地方案 <a class="header-anchor" href="#part-4-多库多租户-datasource-per-tenant-落地方案" aria-label="Permalink to &quot;Part 4：多库多租户（DataSource per tenant）落地方案&quot;">​</a></h2><p>这里是大家最关心、也最容易踩坑的部分：</p><ul><li>每个租户一个库 -&gt; 需要为每个租户维护一个 <code>DataSource</code></li><li>但你不能“每个请求 new 一个 DataSource”，那会把 DB 打爆</li></ul><p>核心思想：</p><ul><li><strong>按 tenantId 缓存 DataSource（Map）</strong></li><li><strong>DataSource 复用连接池</strong></li><li><strong>设定最大租户连接数上限与回收策略</strong></li></ul><h3 id="_1-租户配置从哪里来" tabindex="-1">1）租户配置从哪里来？ <a class="header-anchor" href="#_1-租户配置从哪里来" aria-label="Permalink to &quot;1）租户配置从哪里来？&quot;">​</a></h3><p>你需要一个“租户元数据库”（也叫 <code>tenant_registry</code>）：</p><ul><li>存每个租户的 DB host/user/pass/dbName</li><li>或者存 DSN、schema 名、只读/读写配置等</li></ul><p>通常做法：</p><ul><li>先用一个固定的主库连接（<code>registryDataSource</code>）</li><li>根据请求 tenantId 查询 registry 拿连接信息</li></ul><h3 id="_2-实现一个-tenantdatasourcemanager" tabindex="-1">2）实现一个 <code>TenantDataSourceManager</code> <a class="header-anchor" href="#_2-实现一个-tenantdatasourcemanager" aria-label="Permalink to &quot;2）实现一个 `TenantDataSourceManager`&quot;">​</a></h3><p>伪代码结构（示意用途）：</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TenantDataSourceManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DataSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;();</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  async</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDataSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">tenantId</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DataSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> existed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tenantId);</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (existed?.isInitialized) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> existed;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> config</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loadTenantDbConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tenantId);</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ds</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DataSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mysql&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      host: config.host,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      port: config.port,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      username: config.username,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      password: config.password,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      database: config.database,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      entities: [</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* ... */</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      ],</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      synchronize: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      extra: {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        connectionLimit: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ds.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">initialize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tenantId, ds);</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ds;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>需要你特别注意的点：</p><ul><li><strong>并发初始化</strong>：同一个 tenantId 的并发请求可能导致重复 initialize。 <ul><li>需要加“单飞锁”（Promise in-flight）避免重复创建。</li></ul></li><li><strong>缓存增长</strong>：租户很多时 Map 会无限长。 <ul><li>需要 LRU / TTL 回收，或限制最大租户连接数量。</li></ul></li><li><strong>连接数爆炸</strong>：<code>租户数 * 每租户 pool max * 服务实例数</code> 很快超过 DB 上限。 <ul><li>必须做容量规划。</li></ul></li></ul><h3 id="_3-在-nestjs-里把-按请求选择-datasource-做成-provider" tabindex="-1">3）在 NestJS 里把“按请求选择 DataSource”做成 Provider <a class="header-anchor" href="#_3-在-nestjs-里把-按请求选择-datasource-做成-provider" aria-label="Permalink to &quot;3）在 NestJS 里把“按请求选择 DataSource”做成 Provider&quot;">​</a></h3><p>思路：用 <code>REQUEST</code> 注入拿到 <code>tenantId</code>，然后返回该租户的 DataSource / EntityManager / Repository。</p><p>关键点：</p><ul><li>这个 provider 通常需要 <code>scope: Scope.REQUEST</code>（请求级）</li><li>但 DataSource 本身是缓存复用的（单例管理器里）</li></ul><p>示意结构（仅表达思路）：</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Scope } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@nestjs/common&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { REQUEST } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@nestjs/core&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  provide</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;TENANT_DATASOURCE&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  scope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Scope.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">REQUEST</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">REQUEST</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, TenantDataSourceManager],</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  useFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">req</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mgr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TenantDataSourceManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mgr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getDataSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req.tenantId);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>然后你的 service 里可以注入 <code>&#39;TENANT_DATASOURCE&#39;</code>，再通过 <code>getRepository()</code> 获取 repository。</p><blockquote><p>实战里我更建议注入 <code>EntityManager</code> 或封装 <code>TenantDbService</code>，避免 service 层到处写 <code>getRepository</code>。</p></blockquote><hr><h2 id="part-5-迁移-migrations-怎么处理" tabindex="-1">Part 5：迁移（migrations）怎么处理？ <a class="header-anchor" href="#part-5-迁移-migrations-怎么处理" aria-label="Permalink to &quot;Part 5：迁移（migrations）怎么处理？&quot;">​</a></h2><p>多租户项目最容易被忽略的就是迁移策略。</p><h3 id="单库多租户" tabindex="-1">单库多租户 <a class="header-anchor" href="#单库多租户" aria-label="Permalink to &quot;单库多租户&quot;">​</a></h3><ul><li>迁移跟普通项目一样跑一次即可</li><li>重点是确保所有表都带 <code>tenant_id</code>，并补齐索引</li></ul><h3 id="多库多租户" tabindex="-1">多库多租户 <a class="header-anchor" href="#多库多租户" aria-label="Permalink to &quot;多库多租户&quot;">​</a></h3><p>你有两种常见策略：</p><ul><li><strong>策略 1：新租户创建时跑迁移</strong><ul><li>创建数据库 -&gt; 执行 migrations -&gt; 标记 tenant ready</li></ul></li><li><strong>策略 2：统一批处理迁移</strong><ul><li>发版时遍历租户逐个跑迁移（需要任务队列/可重试）</li></ul></li></ul><p>建议：</p><ul><li>一定要有 <code>schema_version</code> 记录（每个租户一份）</li><li>迁移要可重试、可观测（日志/告警/失败回滚策略）</li></ul><hr><h2 id="part-6-多租户常见坑-踩过一次就会记一辈子" tabindex="-1">Part 6：多租户常见坑（踩过一次就会记一辈子） <a class="header-anchor" href="#part-6-多租户常见坑-踩过一次就会记一辈子" aria-label="Permalink to &quot;Part 6：多租户常见坑（踩过一次就会记一辈子）&quot;">​</a></h2><h3 id="_1-忘了加-tenant-条件-越权漏洞" tabindex="-1">1）忘了加 tenant 条件 = 越权漏洞 <a class="header-anchor" href="#_1-忘了加-tenant-条件-越权漏洞" aria-label="Permalink to &quot;1）忘了加 tenant 条件 = 越权漏洞&quot;">​</a></h3><p>单库多租户里最常见事故：</p><ul><li>代码里有一条 <code>findOne({ where: { id } })</code></li><li>少了 <code>tenant_id</code>，直接把其他租户的数据查出来</li></ul><p>应对：</p><ul><li>代码审计与约束：封装统一 repository/manager</li><li>DB 层隔离：能多库就别单库；或用 RLS（Postgres）</li></ul><h3 id="_2-datasource-per-tenant-没有并发保护" tabindex="-1">2）DataSource per tenant 没有并发保护 <a class="header-anchor" href="#_2-datasource-per-tenant-没有并发保护" aria-label="Permalink to &quot;2）DataSource per tenant 没有并发保护&quot;">​</a></h3><p>并发进来时，多次 initialize 同一个租户 DataSource：</p><ul><li>会创建多组连接池</li><li>连接数飙升，DB 直接被打挂</li></ul><p>应对：</p><ul><li>“in-flight Promise” 单飞锁</li><li>失败时清理缓存，避免脏状态</li></ul><h3 id="_3-连接池配置一把梭-导致-db-max-connections-爆掉" tabindex="-1">3）连接池配置一把梭，导致 DB max_connections 爆掉 <a class="header-anchor" href="#_3-连接池配置一把梭-导致-db-max-connections-爆掉" aria-label="Permalink to &quot;3）连接池配置一把梭，导致 DB max_connections 爆掉&quot;">​</a></h3><p>容量规划公式必须牢记：</p><ul><li><strong>总连接数 ≈ 实例数 × 租户同时活跃数 × 每租户 pool 上限</strong></li></ul><p>应对：</p><ul><li>限制活跃租户 DataSource 数量（LRU 回收）</li><li>热门租户单独实例/单独 DB</li><li>控制 pool 上限 + 降低慢查询</li></ul><h3 id="_4-租户解析来源不可信" tabindex="-1">4）租户解析来源不可信 <a class="header-anchor" href="#_4-租户解析来源不可信" aria-label="Permalink to &quot;4）租户解析来源不可信&quot;">​</a></h3><p>如果你从 <code>x-tenant-id</code> 取租户：</p><ul><li>外部请求很容易伪造 header</li></ul><p>应对：</p><ul><li>tenantId 应该来自 JWT/Session 等可信身份体系</li><li>或者 header 只对内网/网关可信，并在网关做校验与注入</li></ul><hr><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>你在 NestJS + TypeORM 里做“连接池 + 多租户”，建议按这个顺序落地：</p><ol><li>先把<strong>连接池参数</strong>配合理（别盲目拉高）</li><li>明确选择多租户模式： <ul><li>单库多租户：重点是 <strong>tenant_id 强制约束 + 索引</strong></li><li>多库多租户：重点是 <strong>DataSource 缓存复用 + 并发单飞 + 回收 + 容量规划</strong></li></ul></li><li>把迁移/观测/安全边界补齐，否则后期会非常痛苦</li></ol><p>如果你告诉我：</p><ul><li>你用的是 MySQL 还是 Postgres</li><li>租户数大概多少、是否有大客户</li><li>你希望租户从 JWT、子域名还是 header 来</li></ul><p>我可以把文中“示意结构”进一步写成一套更贴近你项目的可复制代码（包括：<code>TenantDataSourceManager</code> 的单飞锁、LRU 回收、以及 Nest Provider 的注入方式）。</p>',126)])])}]]);export{l as __pageData,e as default};
