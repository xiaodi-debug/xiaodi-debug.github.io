---
title: Vue3 学习笔记：一个带搜索和分页的文章列表
tags: [Vue3, 组合式API, 实战笔记, 踩坑记录]
categories: [前端]
date: 2025-11-10
description: 用 Vue3 组合式 API 实战一个带搜索、分页、状态缓存的文章列表页面，并记录中间踩过的坑。
articleGPT: 这是一篇 Vue3 学习笔记，围绕文章列表这个常见业务场景，记录从 0 到 1 搭页面、处理搜索分页、缓存查询条件，以及过程中遇到的响应式和请求竞态问题。
references: []
cover: https://gitee.com/its-liu-xiaodi_admin/my_img/raw/image/vue.png
---

## 背景：为什么从「文章列表」开始练 Vue3？

我在搭自己的博客时发现，一个**常驻存在的页面**就是「文章列表」：

- 要有**搜索**（按标题 / 标签 / 分类）
- 要有**分页**（一次不可能把所有文章都拉下来）
- 要有一点点**状态缓存**（比如从详情页返回时，希望还能看到刚才那一页和搜索条件）

这个场景其实已经比「计数器 Demo」复杂不少，非常适合作为 Vue3 的实战练习。所以这篇就记录一下我用 **Vue3 + 组合式 API** 写这个列表页的过程，以及中间踩的一些坑。

---

## 场景设计：我想要实现什么？

先不写代码，先把需求写清楚：

1. 页面上有这些东西：

   - 搜索框：按文章标题关键字搜索
   - 分类下拉框：按分类筛选
   - 文章列表：显示标题、摘要、标签、发布时间
   - 分页组件：上一页 / 下一页 / 跳转指定页

2. 行为要求：

   - 输入搜索关键字，**500ms 防抖** 后自动请求
   - 切换分类自动刷新列表
   - 切换分页时，保留当前搜索条件和分类
   - 从文章详情页返回列表时，**还能记住用户上一次的搜索条件和页码**

3. 技术点：
   - Vue3 组合式 API（`setup`、`ref`、`reactive`、`computed`、`watch`）
   - 简单的请求封装（这边用假数据模拟，也可以换成真实接口）
   - 利用 `<keep-alive>` 或者自定义「列表状态 store」做状态缓存

---

## 第一步：基本页面骨架（不加搜索和分页）

先把「列表页」的壳搭起来，只展示列表，不做复杂逻辑。这里假设我们有一个 `ArticleList.vue` 组件，结构大概是这样：

```vue
<script setup>
import { ref, onMounted } from "vue";

// 暂时用假数据代替接口请求
const articles = ref([]);

const fetchArticles = async () => {
  // TODO: 替换成真实接口
  articles.value = [
    {
      id: 1,
      title: "Vue3 组合式 API 初体验",
      category: "前端",
      tags: ["Vue3"],
      date: "2025-01-02",
    },
    {
      id: 2,
      title: "用 NestJS 写第一个接口",
      category: "后端",
      tags: ["NestJS"],
      date: "2025-01-05",
    },
    // ...
  ];
};

onMounted(() => {
  fetchArticles();
});
</script>

<template>
  <div class="article-list-page">
    <h1>文章列表</h1>

    <ul class="article-list">
      <li v-for="article in articles" :key="article.id">
        <h2>{{ article.title }}</h2>
        <p>{{ article.category }} · {{ article.date }}</p>
        <p>
          <span v-for="tag in article.tags" :key="tag" class="tag"> #{{ tag }} </span>
        </p>
      </li>
    </ul>
  </div>
</template>
```

这一版很简单，主要是确保：

- 页面能正常渲染
- Vue3 的 `ref` / `onMounted` 用法顺手

---

## 第二步：加入搜索和分页的状态管理

接下来开始加状态。这里我单独抽了一个搜索分页的状态对象：

- `keyword`：搜索关键字
- `category`：当前选择的分类
- `page`：当前页码
- `pageSize`：每页数量
- `total`：总条数

示意代码（只看状态部分）：

```ts
import { ref, reactive, computed, watch } from "vue";

const articles = ref([]);
const loading = ref(false);

const query = reactive({
  keyword: "",
  category: "全部",
  page: 1,
  pageSize: 10,
  total: 0,
});

// 计算总页数
const totalPages = computed(() => {
  return Math.max(1, Math.ceil(query.total / query.pageSize));
});
```

一开始我写接口时，习惯直接：

```ts
query = { ...query, page: newPage };
```

结果在 Vue3 里就出问题了，因为 `reactive` 返回的是一个**代理对象**，整个变量不能被重新赋值，否则会丢掉响应式。正确做法是：

```ts
query.page = newPage;
```

只改具体字段就好。

---

## 第三步：请求函数 + 防抖搜索

搞清楚状态之后，写一个「根据当前 query 发请求」的方法。为方便演示，这里用 `setTimeout` 模拟接口，并记录一个 **请求 ID** 来避免竞态问题。

```ts
import { ref, reactive } from "vue";

const articles = ref([]);
const loading = ref(false);
const query = reactive({
  keyword: "",
  category: "全部",
  page: 1,
  pageSize: 10,
  total: 0,
});

let requestId = 0;

const fakeRequest = (params) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      const all = [
        {
          id: 1,
          title: "Vue3 组合式 API 初体验",
          category: "前端",
          tags: ["Vue3"],
          date: "2025-01-02",
        },
        {
          id: 2,
          title: "Vue3 + TypeScript 实战",
          category: "前端",
          tags: ["Vue3", "TS"],
          date: "2025-01-08",
        },
        {
          id: 3,
          title: "用 Vue3 + Docker 打包前端",
          category: "部署与运维",
          tags: ["Vue3", "Docker"],
          date: "2025-02-01",
        },
        // ... 实际可以更多
      ];

      // 简单过滤：按关键字 + 分类
      let filtered = all.filter((item) => {
        const matchKeyword = params.keyword
          ? item.title.toLowerCase().includes(params.keyword.toLowerCase())
          : true;
        const matchCategory = params.category === "全部" ? true : item.category === params.category;
        return matchKeyword && matchCategory;
      });

      const total = filtered.length;
      const start = (params.page - 1) * params.pageSize;
      const end = start + params.pageSize;
      const list = filtered.slice(start, end);

      resolve({ list, total });
    }, 500);
  });
};

const fetchArticles = async () => {
  loading.value = true;
  const currentId = ++requestId;

  try {
    const { list, total } = await fakeRequest({ ...query });
    // 防止旧请求覆盖新请求
    if (currentId !== requestId) return;

    articles.value = list;
    query.total = total;
  } finally {
    if (currentId === requestId) {
      loading.value = false;
    }
  }
};
```

### 踩坑 2：请求竞态（旧请求覆盖新请求）

如果用户快速切换搜索条件，例如：

- 输入「vue」，马上又改成「docker」

你会触发两次请求。如果第二次请求先返回，第一次请求后返回，就会出现**旧数据覆盖新数据**的问题。所以用 `requestId` 思路做了简单的防护：

- 每次请求前：`currentId = ++requestId`
- 请求回来时：只有 `currentId === requestId` 才认这个结果

---

## 第四步：用 `watch` + 防抖自动触发搜索

现在需要做到：

- 用户改搜索关键字 / 分类时，**自动刷新列表**
- 输入时，不希望每敲一个字就请求一次，需要**防抖**

我这里用最简单的防抖实现（也可以用 lodash）：

```ts
import { watch } from "vue";

let debounceTimer: number | null = null;

const triggerSearch = () => {
  if (debounceTimer) {
    clearTimeout(debounceTimer);
  }
  debounceTimer = window.setTimeout(() => {
    query.page = 1; // 搜索条件变化时，回到第一页
    fetchArticles();
  }, 500);
};

// 监听 keyword 和 category 的变化
watch(
  () => [query.keyword, query.category],
  () => {
    triggerSearch();
  },
);
```

### 踩坑 3：`watch` 源参数要小心引用方式

一开始我写的是：

```ts
watch(query, () => {
  triggerSearch();
});
```

结果发现：

- 只要 `query` 任意字段变化都会触发，包括 `page`、`total` 等
- 容易引起「自己触发自己」，比如在 `fetchArticles` 里更新 `query.total` 也会触发 `watch`，可能导致**额外请求**

后来改成只监听自己真正关心的字段：

```ts
watch(
  () => [query.keyword, query.category],
  () => triggerSearch(),
);
```

更可控，也更清晰。

---

## 第五步：分页切换和状态缓存

分页逻辑很简单：

```ts
const goPage = (page: number) => {
  if (page < 1 || page > totalPages.value) return;
  query.page = page;
  fetchArticles();
};
```

模板里类似：

```vue
<button @click="goPage(query.page - 1)" :disabled="query.page <= 1">上一页</button>
<span>{{ query.page }} / {{ totalPages }}</span>
<button @click="goPage(query.page + 1)" :disabled="query.page >= totalPages">下一页</button>
```

### 状态缓存的思路

我希望：

- 从列表页点进文章详情
- 再返回列表时，**还能记住刚才的搜索关键字 / 分类 / 页码**

思路有两个：

1. 在路由层面，用 `<keep-alive>` 包住列表组件；
2. 或者用一个简单的「全局 store」（比如 `pinia`，或者自己写一个模块）来保存 `query` 状态和 `articles` 列表。

这里简单说下 **keep-alive 的坑**：

- 只有通过 `router-view` 渲染出来的组件，且被 `<keep-alive>` 包裹，才会缓存
- 组件会触发 `activated` / `deactivated` 钩子
- 常见误区：在 `onMounted` 里直接请求数据，但组件被 keep-alive 后，从详情返回时**不会重新 mounted**，这时你可能需要在 `onActivated` 里按需刷新

一个简单模式：

```ts
import { onMounted, onActivated } from "vue";

let inited = false;

onMounted(() => {
  fetchArticles();
  inited = true;
});

onActivated(() => {
  // 如果你希望每次回来都刷新，可以这里判断
  // 如果只想第一次加载，就什么都不做
});
```

如果你改用 store 保存列表状态，就可以在 `setup` 里先从 store 里恢复 `query` 和 `articles`，需要的时候再决定要不要重新请求。

---

## 最后：这一轮 Vue3 实战我学到了什么？

总结一下这次用 Vue3 写「带搜索和分页的文章列表」我踩过的几个点：

- **reactive 不能整体替换**  
  只能改里面的字段，否则会丢响应式。

- **请求要考虑竞态**  
  当用户频繁操作时，旧请求返回可能覆盖新请求，简单的 `requestId` 能避免不少问题。

- **watch 源尽量精确**  
  只监听真正变化会触发业务的字段，例如 `[query.keyword, query.category]`，避免无意义的重复请求。

- **防抖和用户体验**  
  输入搜索时加 500ms 防抖，明显减少了无用请求，又不会显得太「迟钝」。

- **状态缓存的设计要提前想好**  
  尤其是列表 + 详情的场景，返回时记住状态，会给用户带来很大体验提升。

后面我会基于这个列表页继续做一些扩展，比如：

- 加上**标签多选筛选**
- 支持**排序**（按时间 / 热度）
- 和实际的后端（比如 NestJS + MySQL）打通，变成真正的全栈实战

如果你也在学 Vue3，希望这篇「学习笔记 + 踩坑记录」能给你一点启发，也欢迎和我一起继续走在「大神之路」上。
